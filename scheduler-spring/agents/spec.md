# Dynamic Scheduler System – Requirements (Explicit Policy Version)

## 1. 목적 (Goal)

본 시스템은 **사전에 등록된 기능(Task)을 스케줄 또는 수동 요청에 의해 실행**하기 위한
**범용 동적 스케줄러 시스템**이다.

- Task는 **정해진 시점(스케줄)** 또는 **수동 요청**에 의해 실행될 수 있다.
- 스케줄은 **동적으로 등록, 변경, 삭제** 가능해야 한다.
- 서비스는 **다중 인스턴스 환경**에서 동작할 수 있다.
- 모든 실행은 **정확히 한 번(Exactly Once)** 수행되어야 한다.

---

## 2. 핵심 용어 정의

- **Task**
  - 스케줄러에 의해 실행되는 기능 단위
  - 애플리케이션에 사전 등록된 실행 로직
  - 고유한 `task_id`로 식별됨

- **Schedule**
  - Task를 자동으로 실행하기 위한 시점 규칙
  - Cron 표현식 또는 특정 시점 기반

- **Manual Execution**
  - 스케줄과 무관하게 **사용자 또는 시스템 요청에 의해 Task를 즉시 실행하는 행위**

- **Execution**
  - Schedule 또는 Manual Execution에 의해 생성되는 **단일 Task 실행 단위**
  - Exactly Once 보장의 최소 단위

- **Instance**
  - 동일한 애플리케이션의 실행 노드
  - 1대 이상일 수 있음

- **Global Timezone**
  - 시스템의 모든 스케줄링 및 실행 시간 기준은 **KST (Asia/Seoul)** 를 따른다.
  - 모든 Cron 표현식과 Timestamp는 KST 기준으로 처리 및 저장된다.

---

## 3. 기능 요구사항 (Functional Requirements)

### 3.1 Task 관리

- 시스템은 **여러 종류의 Task를 등록**할 수 있어야 한다.
- 각 Task는 **고유한 식별자(Task ID)** 로 참조 가능해야 한다.
- Task는 스케줄과 **분리되어 관리**되어야 한다.
- 스케줄 및 수동 실행은 **이미 등록된 Task만 참조**할 수 있다.

---

### 3.2 스케줄 관리

- 특정 Task에 대해 **스케줄을 동적으로 등록**할 수 있어야 한다.
- 기존 스케줄을 **수정**할 수 있어야 한다.
  - 실행 시점 변경
  - 일시 정지 / 재개
- 스케줄을 **삭제**할 수 있어야 한다.
- 스케줄 변경은 **서비스 재시작 없이 즉시 반영**되어야 한다.

---

### 3.3 수동 실행 (Manual Execution)

- 특정 Task를 **수동으로 즉시 실행**할 수 있어야 한다.
- 수동 실행은 스케줄과 **완전히 독립적으로 동작**해야 한다.
- 수동 실행 요청은 **항상 새로운 Execution을 생성**해야 한다.
- 동일한 Task가 이미 실행 중인 경우,
  - 수동 실행 요청은 **거부(HTTP 409 Conflict)** 되어야 한다.
  - 중복 실행은 **허용하지 않는다**.
- 수동 실행 역시 **Exactly Once 보장 대상**에 포함된다.

---

### 3.4 실행 (Execution)

- 스케줄 또는 수동 요청에 의해 **Execution이 생성**된다.
- Execution은 **하나의 Task 실행을 의미**한다.
- 동일한 Execution에 대해 **Task는 한 번만 실행**되어야 한다.
- Execution은 다음 상태를 가진다.
  - PENDING
  - RUNNING
  - SUCCESS
  - FAILED

---

### 3.5 정확히 한 번 실행 (Exactly Once)

- Exactly Once는 **Execution 단위**로 보장한다.
- 각 Execution은 **고유한 execution_id**를 가져야 한다.
- execution_id는 **중복될 수 없으며**, DB 수준에서 **Unique Constraint**로 보장되어야 한다.
- 아래 상황에서도 동일 Execution에 대한 Task는 **한 번만 실행**되어야 한다.
  - 다중 인스턴스에서 동시에 실행 요청이 발생한 경우
  - 실행 도중 인스턴스 장애가 발생한 경우
  - 재시도 또는 지연 실행이 발생한 경우
- 중복 실행 시도가 발생하더라도,
  - **Execution 획득 단계에서 중복이 차단**되어야 한다.

---

### 3.6 실행 획득 및 동시성 제어

- Execution 실행은 **다중 인스턴스 환경에서도 단일 인스턴스만 수행**해야 한다.
- Execution 실행 권한은 **DB 기반 락 또는 Lease 방식**으로 획득해야 한다.
  - 상태 전이(PENDING → RUNNING)는 **원자적으로 처리**되어야 한다.
  - 하나의 Execution은 동시에 두 인스턴스에서 RUNNING 상태가 될 수 없다.
- 락 획득에 실패한 인스턴스는 해당 Execution을 실행하지 않아야 한다.

#### 스케줄 중복 실행 정책 (Overlap Policy)
- Task 실행 시간이 스케줄 주기보다 길어질 경우 (이전 실행이 아직 끝나지 않은 경우):
  - **Skip**: 이번 회차 실행은 **생략(Skip)** 한다.
  - 큐잉하지 않고 즉시 종료 처리하며, 다음 주기에 다시 시도한다.

---

### 3.7 장애 및 재시도 (Retry Strategy)

- Task 실행 실패 시, **재시도 가능**해야 한다.
- 재시도는 **동일 Execution을 재사용**해야 하며, 새로운 Execution을 생성해서는 안 된다.
- **재시도 정책**:
  - **최대 재시도 횟수**: 기본 **3회** (설정 가능)
  - **백오프(Backoff)**: 지수 백오프(Exponential Backoff) 적용 권장
- 재시도 중에도 **Exactly Once 보장**은 유지되어야 한다.

---

### 3.8 장애 감지 및 복구 (Zombie Handling)

- 인스턴스 비정상 종료(OOM, Power Off 등)로 인해, 실제로 실행 중이지 않으나 상태가 `RUNNING`으로 남은 Execution(좀비 상태)을 처리해야 한다.
- **Recovery Daemon**:
  - 주기적으로 `RUNNING` 상태이면서 `locked_until`(또는 heartbeat) 시간이 만료된 건을 조회한다.
  - 해당 Execution을 `FAILED` 처리하거나 `PENDING`으로 되돌려 **재시도** 한다.

---

### 3.9 데이터 관리 정책 (Retention)

- **Execution 이력 보관**:
  - 완료된(SUCCESS/FAILED) Execution 이력은 무한정 쌓일 수 없다.
- **자동 정리 (Cleanup)**:
  - **보관 주기**: 기본 **30일** (설정 가능)
  - 보관 주기가 지난 이력은 별도 **Cleanup Batch**를 통해 주기적으로 삭제한다.

---

## 4. 비기능 요구사항 (Non-Functional Requirements)

### 4.1 신뢰성

- Task, Schedule, Execution 정보는 **영속적으로 저장**되어야 한다.
- 서비스 재시작 후에도 스케줄은 유지되어야 한다.
- 실행 중 장애 발생 시에도 **상태 복구가 가능**해야 한다.

### 4.2 확장성

- 스케줄 개수 및 실행 빈도가 증가해도 시스템이 확장 가능해야 한다.
- Task 실행 로직은 스케줄링 로직과 **명확히 분리**되어야 한다.

### 4.3 관측성 (Observability)

- 각 Execution에 대해 다음 정보를 확인할 수 있어야 한다.
  - Task ID
  - 실행 유형 (SCHEDULE / MANUAL)
  - 실행 시각
  - 실행 상태
  - 재시도 횟수
- 로그 및 메트릭을 통해 문제 분석이 가능해야 한다.

---

## 5. 제약 사항 (Constraints)

- Task 실행 시간은 짧을 수도, 길 수도 있다.
- Task 실행 중 장애가 발생할 수 있다.
- 애플리케이션 레벨에서 **중복 실행 방지**가 필수다.

---

## 6. 설계 시 고려 사항 (Design Considerations)

- 스케줄 트리거와 실제 Task 실행은 **반드시 분리**되어야 한다.
- Exactly Once 보장을 위한 **Execution 중심 설계**가 필요하다.
- 스케줄 변경과 실행 간의 경합 상황을 고려해야 한다.
- 다중 인스턴스 환경에서의 **실행 권한 경쟁**을 안전하게 처리해야 한다.
- Spring Scheduling 기반 폴링 적용 시 다음 원칙을 따른다.
  - 스케줄 정의는 DB에 저장하고 폴러가 due 스케줄을 배치로 잠근다.
  - 실행 시 `taskId`로 DB에서 스케줄/설정 정보를 로딩한다.
  - 스케줄 변경은 다음 폴링 사이클에서 반영한다.
  - 실행 직전 DB **lease 락**으로 중복 실행을 차단한다.
- **영속성 확보**:
  - 스케줄과 실행 상태는 DB에 저장하여 인스턴스 재시작 간 스케줄 소실을 방지한다.
  - 클러스터 환경에서 락 만료/재획득으로 장애 복구가 가능해야 한다.

---

## 7. 범위 외 (Out of Scope)

- Task 내부 비즈니스 로직의 상세 구현
- Task 실행 결과에 대한 보상 트랜잭션
- 사용자 인증/권한 관리
